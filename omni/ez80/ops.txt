;OPCODE					MNEMONIC		BYTES		CYCLES				FLAGS		DESCRIPTION


;PRIMARY INSTRUCTIONS

00000000				nop			1		1F				--------	No operation is performed.
00001000				ex af,af'		1		1F				--------	Exchanges the contents of .reg24af[3;1] and .reg24sh[3;1].
00010000........			djnz ofs8		2		b-1 ? 3F+1 : 2F			--------	.reg8[0;1] is decremented, and if not zero, the signed value .ofs8[] is added to .regpc[] (after the instruction). `if (--.reg8[0;1]) .regpc[] += .ofs8[]`
00011000........			jr ofs8			2		3F				--------	The signed value .ofs8[] is added to .regpc[] (after the instruction). `.regpc[] += .ofs8[]`
001..000........			jr cc,ofs8		2		cc ? 3F+1 : 2F			--------	If condition .cc[] is true, the signed value .ofs8[] is added to .regpc[] (after the instruction). `if (.cc[]) .regpc[] += .ofs8[]`

00..0001................		ld reg24,imm24		4		(3+.il)F			--------	Loads .imm24[] into .reg24[]. `.reg16[] = .imm16[]`
00..1001				add hl,reg24		1		1F				---H--NC	The value of .reg24[] is added to .reg24[2;1]. `.reg16[2;1] += .reg16[]`

00000010				ld (bc),a		1		1F+1W				--------	Stores .reg8[7;1] into the byte of memory pointed to by .reg24[0;1]. `*(char*).reg24[0;1] = .reg8[7;1]`
00010010				ld (de),a		1		1F+1W				--------	Stores .reg8[7;1] into the byte of memory pointed to by .reg24[1;1]. `*(char*).reg24[1;1] = .reg8[7;1]`
00100010................		ld (imm24),hl		4		(3+.il)F+(2+.l)W		--------	Stores .reg24[2;1] into the word of memory pointed to by .imm24[]. `*(int*).imm24[] = .reg24[2;1]`
00110010................		ld (imm24),a		4		(3+.il)F+1W			--------	Stores .reg8[7;1] into the byte of memory pointed to by .imm24[]. `*(char*).imm24[] = .reg8[7;1]`
00001010				ld a,(bc)		1		1F+1R				--------	Loads the byte of memory pointed to by .reg24[0;1] into .reg8[7;1]. `.reg8[7;1] = *(char*).reg24[0;1]`
00011010				ld a,(de)		1		1F+1R				--------	Loads the byte of memory pointed to by .reg24[1;1] into .reg8[7;1]. `.reg8[7;1] = *(char*).reg24[1;1]`
00101010................		ld hl,(imm24)		4		(3+.il)F+(2+.l)R		--------	Loads the word of memory pointed to by .imm24[] into .reg24[2;1]. `.reg24[2;1] = *(int*).imm24[]`
00111010................		ld a,(imm24)		4		(3+.il)F+1R			--------	Loads the byte of memory pointed to by .imm24[] into .reg8[7;1]. `.reg8[7;1] = *(char*).imm24[]`

00..0011				inc reg24		1		1F				--------	Adds one to .reg24[]. `.reg24[]++`
00..1011				dec reg24		1		1F				--------	Subtracts one from .reg24[]. `.reg24[]--`

00110100				inc (hl)		1		1F+1R+1W+1			SZ-H-VN-	Adds one to .reg8[6]. `*(char*).reg24[2;1]++`
00...100				inc reg8		1		1F				SZ-H-VN-	Adds one to .reg8[]. `.reg8[]++`

00110101				dec (hl)		1		1F+1R+1W+1			SZ-H-VN-	Subtracts one from .reg8[6]. `*(char*).reg24[2;1]--`
00...101				dec reg8		1		1F				SZ-H-VN-	Subtracts one from .reg8[]. `.reg8[]--`

00110110........			ld (hl),imm8		2		2F+1W				--------	Loads .imm8[] into .reg8[6]. `*(char*).reg24[2;1] = .imm8[]`
00...110........			ld reg8,imm8		2		2F				--------	Loads .imm8[] into .reg8[]. `*.reg8[] = .imm8[]`

00000111				rlca			1		1F				---0--0C	The contents of .reg8[7;1] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and bit 0. `.reg8[7;1] = .reg8[7;1] << 1 | (uint8_t).reg8[7;1] >> 7`
00001111				rrca			1		1F				---0--0C	The contents of .reg8[7;1] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and bit 7. `.reg8[7;1] = (uint8_t).reg8[7;1] >> 1 | .reg8[7;1] << 7`
00010111				rla			1		1F				---0--0C	The contents of .reg8[7;1] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and the previous contents of .f[3] are copied to bit 0. `.reg8[7;1] = .reg8[7;1] << 1 | .f[3]`
00011111				rra			1		1F				---0--0C	The contents of .reg8[7;1] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of .f[3] are copied to bit 7. `.reg8[7;1] = (uint8_t).reg8[7;1] >> 1 | .f[3] << 7`
00100111				daa			1		1F				SZ-*-P-*	Adjusts .reg8[7;1] for BCD addition and subtraction operations.
00101111				cpl			1		1F				---1--1-	The contents of .reg8[7;1] are inverted (one's complement). `.reg8[7;1] = ~.reg8[7;1]`
00110111				scf			1		1F				---0--01	Sets .f[3]. `.f[3] = 1`
00111111				ccf			1		1F				---*--0*	Inverts .f[3]. `.f[3] = ~.f[3]`

010.00.011...000			ret.s cc		2		cc ? 3F+(3+(*SPL&1))R+2 : 2F+1	--------	If condition .cc[] is true, a byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].
010.10.111...000			ret.l cc		2		cc ? 3F+(3+(*SPL&1))R+2 : 2F+1	--------	If condition .cc[] is true, a byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].

010.00.011001001			ret.s			2		3F+(3+(*SPL&1))R+1		--------	A byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].
010.10.111001001			ret.l			2		3F+(3+(*SPL&1))R+1		--------	A byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].

010.00.01110110101000101		retn.s			3		4F+(3+(*SPL&1))R+1		--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.10.11110110101000101		retn.l			3		4F+(3+(*SPL&1))R+1		--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.00.01110110101001101		reti.s			3		4F+(3+(*SPL&1))R+1		--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.10.11110110101001101		reti.l			3		4F+(3+(*SPL&1))R+1		--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.

010.00.011101001			jp.s (hl)		2		4F				--------	ADL mode is reset and loads the value of .reg16[2;1] into .regpc[].
010.10.111101001			jp.l (hl)		2		4F				--------	ADL mode is set and loads the value of .reg24[2;1] into .regpc[].

010.00.01101110111101001		jp.s (ix)		3		5F				--------	ADL mode is reset and loads the value of .regi[] into .regpc[].
010.10.11101110111101001		jp.l (ix)		3		5F				--------	ADL mode is set and loads the value of .regi[] into .regpc[].

010.00.01101111111101001		jp.s (iy)		3		5F				--------	ADL mode is reset and loads the value of .regi[] into .regpc[].
010.10.11101111111101001		jp.l (iy)		3		5F				--------	ADL mode is set and loads the value of .regi[] into .regpc[].

0100000011...010................	jp.sis cc,imm16		4		cc ? 4F+1 : 4F			--------	If condition .cc[] is true, ADL mode is reset and .imm16[] is copied to .regpc[].
0100100111...010................	jp.lis cc,imm16		4		cc ? 4F+1 : 4F			--------	If condition .cc[] is true, ADL mode is set and .imm16[] is copied to .regpc[].
0101001011...010................	jp.sil cc,imm24		5		cc ? 5F+1 : 5F			--------	If condition .cc[] is true, ADL mode is reset and .imm24[]&.imm16[h;FFFF;1] is copied to .regpc[].
0101101111...010................	jp.lil cc,imm24		5		cc ? 5F+1 : 5F			--------	If condition .cc[] is true, ADL mode is set and .imm24[] is copied to .regpc[].

0100000011000011................	jp.sis imm16		4		4F+1				--------	ADL mode is reset and .imm16[] is copied to .regpc[].
0100100111000011................	jp.lis imm16		4		4F+1				--------	ADL mode is reset and .imm16[] is copied to .regpc[].
0101001011000011................	jp.sil imm24		5		5F+1				--------	ADL mode is set and .imm24[]&.imm16[h;FFFF;1] is copied to .regpc[].
0101101111000011................	jp.lil imm24		5		5F+1				--------	ADL mode is set and .imm24[] is copied to .regpc[].

0100000011...100................	call.sis cc,imm16	4		cc ? 4F+3W : 4F			--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0100100111...100................	call.lis cc,imm16	4		cc ? 4F+4W ; 4F			--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0101001011...100................	call.sil cc,imm24	5		cc ? 5F+3W : 5F			--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].
0101101111...100................	call.lil cc,imm24	5		cc ? 5F+4W : 5F			--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].

0100000011001101................	call.sis imm16		4		4F+3W				--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0100100111001101................	call.lis imm16		4		4F+4W				--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0101001011001101................	call.sil imm24		5		5F+3W				--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].
0101101111001101................	call.lil imm24		5		5F+4W				--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].

0100000011...111................	rst.sis imm8		2		3F+3W+1				--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .dec2h[].
0100100111...111................	rst.lis imm8		2		3F+4W+1				--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .dec2h[].
0101001011...111................	rst.sil imm8		2		3F+3W+1				--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .dec2h[].
0101101111...111................	rst.lil imm8		2		3F+4W+1				--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .dec2h[].

01110110				halt			1		1F				--------	Suspends CPU operation until an interrupt or reset occurs.

01...110				ld reg8,(hl)		1		1F+1R				--------	The contents of .reg8[6] are loaded into .reg8[]. `.reg8[] = *(char*).reg24[2;1]`
01110...				ld (hl),reg8		1		1F+1W				--------	The contents of .reg8[] are loaded into .reg8[6]. `*(char*).reg24[2;1] = .reg8[]`
01......				ld reg8,reg8		1		1F				--------	The contents of the second .reg8[] are loaded into the first .reg8[]. `.reg8[] = .reg8[]`

10000110				add a,(hl)		1		1F+1R				SZ-H-VNC	Adds .reg8[6] to .reg8[7;1]. `.reg8[7;1] += *(char*).reg24[2;1]`
10000...				add a,reg8		1		1F				SZ-H-VNC	Adds .reg8[] to .reg8[7;1]. `.reg8[7;1] += .reg8[]`
10001110				adc a,(hl)		1		1F+1R				SZ-H-VNC	Adds .reg8[6] and .f[3] to .reg8[7;1]. `.reg8[7;1] += *(char*).reg24[2;1] + .f[3]`
10001...				adc a,reg8		1		1F				SZ-H-VNC	Adds .reg8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += .reg8[] + .f[3]`
10010110				sub a,(hl)		1		1F+1R				SZ-H-VNC	Subtracts .reg8[6] from .reg8[7;1]. `.reg8[7;1] -= *(char*).reg24[2;1]`
10010...				sub a,reg8		1		1F				SZ-H-VNC	Subtracts .reg8[] from .reg8[7;1]. `.reg8[7;1] -= .reg8[]`
10011110				sbc a,(hl)		1		1F+1R				SZ-H-VNC	Subtracts .reg8[6] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= *(char*).reg24[2;1] + .f[3]`
10011...				sbc a,reg8		1		1F				SZ-H-VNC	Subtracts .reg8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= .reg8[] + .f[3]`
10100110				and a,(hl)		1		1F+1R				SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[6]. `.reg8[7;1] &= *(char*).reg24[2;1]`
10100...				and a,reg8		1		1F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[]. `.reg8[7;1] &= .reg8[]`
10101110				xor a,(hl)		1		1F+1R				SZ-0-P00	Bitwise XOR on .reg8[7;1] with .reg8[6]. `.reg8[7;1] ^= *(char*).reg24[2;1]`
10101...				xor a,reg8		1		1F				SZ-0-P00	Bitwise XOR on .reg8[7;1] with .reg8[]. `.reg8[7;1] ^= .reg8[]`
10110110				or a,(hl)		1		1F+1R				SZ-0-P00	Bitwise OR on .reg8[7;1] with .reg8[6]. `.reg8[7;1] |= *(char*).reg24[2;1]`
10110...				or a,reg8		1		1F				SZ-0-P00	Bitwise OR on .reg8[7;1] with .reg8[]. `.reg8[7;1] |= .reg8[]`
10111110				cp a,(hl)		1		1F+1R				SZ-H-VNC	Subtracts .reg8[6] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
10111...				cp a,reg8		1		1F				SZ-H-VNC	Subtracts .reg8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

11...000				ret cc			1		cc ? 2F+(2+.l)R+2 : 1F+1	--------	If condition .cc[] is true, the top stack entry is popped into .regpc[]. `if (.cc[]) .regpc[] = *(*(int**)&.reg24[3;1])++`

11..0001				pop reg24af		1		1F+(2+.l)R			--------	The word of memory pointed to by .reg24[3;1] is stored into .reg24af[] and .reg24[3;1] is incremented by the word size. `.reg24af[] = *(*(int**)&.reg24[3;1])++`
11001001				ret			1		2F+(2+.l)R+1			--------	The top stack entry is popped into .regpc[]. `.regpc[] = *(*(int**)&.reg24[3;1])++`
11011001				exx			1		1F				--------	Exchanges the contents of .reg24[0;1], .reg24[1;1], and .reg24[2;1] with .reg24sh[0;1], .reg24sh[1;1], and .reg24sh[2;1].
11101001				jp (hl)			1		3F				--------	Loads the value of .reg24[2;1] into .regpc[]. `.regpc[] = .reg24[2;1]`
11111001				ld sp,hl		1		1F				--------	Loads the value of .reg24[2;1] into .reg24[3;1]. `.reg24[3;1] = .reg24[2;1]`

11...010................		jp cc,imm24		4		cc ? (3+.il)F+1 : (3+.il)F	--------	If condition .cc[] is true, .imm24[] is copied to .regpc[]. `if (.cc[]) .regpc[] = .imm24[]`

11000011................		jp imm24		4		(3+.il)F+1			--------	.imm24[] is copied to .regpc[]. `.regpc[] = .imm24[]`
;11001011				BIT INSTRUCTIONS
11010011........			out (imm8),a		2		2F+1W				--------	Writes .reg8[7;1] to port {.reg8[7;1], .imm8[]}
11011011........			in a,(imm8)		2		2F+1R				--------	Reads a byte from port {.reg8[7;1], .imm8[]} to .reg8[7;1].
11100011				ex (sp),hl		1		1F+(2+.l)R+(2+.l)W		--------	Exchanges the word of memory pointed to by .reg24[3;1] with .reg24[2;1].
11101011				ex de,hl		1		1F				--------	Exchanges the contents of .reg24[1;1] and .reg24[2;1].
11110011				di			1		1F				--------	Resets both interrupt flip-flops, thus preventing maskable interrupts from triggering.
11111011				ei			1		1F				--------	Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction.

11...100................		call cc,imm24		4		cc ? (3+.il)F+3W : (3+.il)F	--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the stack, then is loaded with .imm24[]. `if (.cc[]) *--*(int**)&.reg24[3;1] = .regpc[], .regpc[] = .imm24[]`

11..0101				push reg24af		1		1F+(2+.l)W			--------	.reg24[3;1] is decremented by the word size and .reg24af[] is stored into the word of memory pointed to by .reg24[3;1]. `*--*(int**)&.reg24[3;1] = .reg24af[]`
11001101................		call imm24		4		(3+.il)F+(2+.il)W		--------	The .regpc[] value after this instruction is pushed onto the stack, then is loaded with .imm24[]. `*--*(int**)&.reg24[3;1] = .regpc[], .regpc[] = .imm24[]`
;11011101				IX PRIMARY INSTRUCTIONS
;11101101				EXTENDED INSTRUCTIONS
;11111101				IY PRIMARY INSTRUCTIONS

11000110........			add a,imm8		2		2F				SZ-H-VNC	Adds .imm8[] to .reg8[7;1]. `.reg8[7;1] += .imm8[]`
11001110........			adc a,imm8		2		2F				SZ-H-VNC	Adds .imm8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += .imm8[] + .f[3]`
11010110........			sub a,imm8		2		2F				SZ-H-VNC	Subtracts .imm8[] from .reg8[7;1]. `.reg8[7;1] -= .imm8[]`
11011110........			sbc a,imm8		2		2F				SZ-H-VNC	Subtracts .imm8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= .imm8[] + .f[3]`
11100110........			and a,imm8		2		2F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .imm8[]. `.reg8[7;1] &= .imm8[]`
11101110........			xor a,imm8		2		2F				SZ-0-P00	Bitwise XOR on .reg8[7;1] with .imm8[]. `.reg8[7;1] ^= .imm8[]`
11110110........			or a,imm8		2		2F				SZ-0-P00	Bitwise OR on .reg8[7;1] with .imm8[]. `.reg8[7;1] |= .imm8[]`
11111110........			cp a,imm8		2		2F				SZ-H-VNC	Subtracts .imm8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

11...111				rst imm8		1		2F+(2+.l)W+1			--------	The .regpc[] value after this instruction is pushed onto the stack, then is loaded with .dec2h[]. `*--*(int**)&.reg24[3;1] = .regpc[], .regpc[] = .dec2h[]`


;BIT INSTRUCTIONS

1100101100000110			rlc (hl)		2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and bit 0. `*(char*).reg24[2;1] = *(char*).reg24[2;1] << 1 | *(uint8_t*).reg24[2;1] >> 7`
1100101100000...			rlc reg8		2		2F				SZ-0-P0C	The contents of .reg8[] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and bit 0. `.reg8[7;1] = .reg8[7;1] << 1 | (uint8_t).reg8[7;1] >> 7`
1100101100001110			rrc (hl)		2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and bit 7. `*(char*).reg24[2;1] = *(uint8_t*).reg24[2;1] >> 1 | *(char*).reg24[2;1] << 7`
1100101100001...			rrc reg8		2		2F				SZ-0-P0C	The contents of .reg8[] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and bit 7. `.reg8[7;1] = (uint8_t).reg8[7;1] >> 1 | .reg8[7;1] << 7`
1100101100010110			rl (hl)			2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and the previous contents of .f[3] are copied to bit 0. `*(char*).reg24[2;1] = *(char*).reg24[2;1] << 1 | .f[3]`
1100101100010...			rl reg8			2		2F				SZ-0-P0C	The contents of .reg8[] are rotated left one bit position. The contents of bit 7 are copied to .f[3] and the previous contents of .f[3] are copied to bit 0. `.reg8[7;1] = .reg8[7;1] << 1 | .f[3]`
1100101100011110			rr (hl)			2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of .f[3] are copied to bit 7. `*(char*).reg24[2;1] = *(uint8_t*).reg24[2;1] >> 1 | .f[3] << 7`
1100101100011...			rr reg8			2		2F				SZ-0-P0C	The contents of .reg8[] are rotated right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of .f[3] are copied to bit 7. `.reg8[7;1] = (uint8_t).reg8[7;1] >> 1 | .f[3] << 7`
1100101100100110			sla (hl)		2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are shifted left one bit position. The contents of bit 7 are copied to .f[3] and a zero is put into bit 0. `*(char*).reg24[2;1] = *(char*).reg24[2;1] << 1`
1100101100100...			sla reg8		2		2F				SZ-0-P0C	The contents of .reg8[] are shifted left one bit position. The contents of bit 7 are copied to .f[3] and a zero is put into bit 0. `.reg8[7;1] = .reg8[7;1] << 1`
1100101100101110			sra (hl)		2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are shifted right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of bit 7 are unchanged. `*(char*).reg24[2;1] = *(char*).reg24[2;1] >> 1`
1100101100101...			sra reg8		2		2F				SZ-0-P0C	The contents of .reg8[] are shifted right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of bit 7 are unchanged. `.reg8[7;1] = (char).reg8[7;1] >> 1`
1100101100110...			trap			2		2F				--------	It's a trap!
1100101100111110			srl (hl)		2		2F+1R+1W+1			SZ-0-P0C	The contents of .reg8[6] are shifted right one bit position. The contents of bit 0 are copied to .f[3] and a zero is put into bit 7. `*(char*).reg24[2;1] = *(uint8_t*).reg24[2;1] >> 1`
1100101100111...			srl reg8		2		2F				SZ-0-P0C	The contents of .reg8[] are shifted right one bit position. The contents of bit 0 are copied to .f[3] and a zero is put into bit 7. `.reg8[7;1] = (uint8_t).reg8[7;1] >> 1`

1100101101...110			bit imm3,(hl)		2		2F+1R				*Z-1-*0-	Tests bit .imm3[] of .reg8[6].
1100101101......			bit imm3,reg8		2		2F				*Z-1-*0-	Tests bit .imm3[] of .reg8[].

1100101110...110			res imm3,(hl)		2		2F+1R+1W+1			--------	Resets bit .imm3[] of .reg8[6]. `*(char*).reg24[2;1] &= ~(1 << .imm3[])`
1100101110......			res imm3,reg8		2		2F				--------	Resets bit .imm3[] of .reg8[]. `.reg8[] &= ~(1 << .imm3[])`

1100101111...110			set imm3,(hl)		2		2F+1R+1W+1			--------	Sets bit .imm3[] of .reg8[6]. `*(char*).reg24[2;1] |= 1 << .imm3[]`
1100101111......			set imm3,reg8		2		2F				--------	Sets bit .imm3[] of .reg8[]. `.reg8[] |= 1 << .imm3[]`


;EXTENDED INSTRUCTIONS

1110110100110000........		in0 (imm8)		3		3F+1R				SZ-0-P0-	Reads a byte from port .imm8[], affecting flags only.
1110110100...000........		in0 reg8,(imm8)		3		3F+1R				SZ-0-P0-	Reads a byte from port .imm8[] to .reg8[].

1110110100110001			ld iy,(hl)		2		2F+(2+.l)R			--------	Loads the word of memory pointed to by .reg24[2;1] into .regi[1]. `.regi[1] = *(int*).reg24[2;1]`
1110110100...001........		out0 reg8,(imm8)	3		3F+1W				--------	Writes .reg8[] to port .imm8[].

1110110100110010........		lea ix,ix+ofs8		3		3F				--------	Stores .regi[0] plus .ofs8[] into .regi[0]. `.regi[0] += .ofs8[]`
1110110100..0010........		lea reg24,ix+ofs8	3		3F				--------	Stores .regi[0] plus .ofs8[] into .reg24[]. `.reg24[] = .regi[0] + .ofs8[]`

1110110100110011........		lea iy,iy+ofs8		3		3F				--------	Stores .regi[1] plus .ofs8[] into .regi[1]. `.regi[1] += .ofs8[]`
1110110100..0011........		lea reg24,iy+ofs8	3		3F				--------	Stores .regi[1] plus .ofs8[] into .reg24[]. `.reg24[] = .regi[1] + .ofs8[]`

1110110100110100			tst a,(hl)		2		2F+1R				SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[6] and affects flags according to the result. .reg8[7;1] is not modified.
1110110100...100			tst a,reg8		2		2F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[] and affects flags according to the result. .reg8[7;1] is not modified.

1110110100111110			ld (hl),iy		2		2F+(2+.l)W			--------	Stores .regi[1] into the word of memory pointed to by .reg24[2;1]. `*(int*).reg24[2;1] = .regi[1]`

1110110100110111			ld ix,(hl)		2		2F+(2+.l)R			--------	Loads the word of memory pointed to by .reg24[2;1] into .regi[0]. `.regi[0] = *(int*).reg24[2;1]`
1110110100..0111			ld reg24,(hl)		2		2F+(2+.l)R			--------	Loads the word of memory pointed to by .reg24[2;1] into .reg24[]. `.reg24[] = *(int*).reg24[2;1]`
1110110100111111			ld (hl),ix		2		2F+(2+.l)W			--------	Stores .regi[0] into the word of memory pointed to by .reg24[2;1]. `*(int*).reg24[2;1] = .regi[0]`
1110110100..1111			ld (hl),reg24		2		2F+(2+.l)W			--------	Stores .reg24[] into the word of memory pointed to by .reg24[2;1]. `*(int*).reg24[2;1] = .reg24[]`

1110110101110000			in (bc)			2		2F+1R				SZ-0-P0-	Reads a byte from port .reg16[0;1], affecting flags only.
1110110101...000			in reg8,(bc)		2		2F+1R				SZ-0-P0-	Reads a byte from port .reg16[0;1] to .reg8[].

1110110101110001			trap			2		2F				--------	It's a trap!
1110110101...001			out (bc),reg8		2		2F+1W				--------	Writes .reg8[] to port .reg16[0;1].

1110110101..0010			sbc hl,reg24		2		2F				SZ-H-VNC	Subtracts .reg24[] and .f[3] from .reg24[2;1]. `.reg24[2;1] -= .reg24[] + .f[3]`
1110110101..1010			adc hl,reg24		2		2F				SZ-H-VNC	Adds .reg24[] and .f[3] to .reg24[2;1]. `.reg24[2;1] += .reg24[] + .f[3]`

1110110101..0011................	ld (imm24),reg24	5		(4+.il)F+(2+.l)W		--------	Stores .reg24[] into the word of memory pointed to by .imm24[]. `*(int*).imm24[] = .reg24[]`
1110110101..1011................	ld reg24,(imm24)	5		(4+.il)F+(2+.l)R		--------	Loads the word of memory pointed to by .imm24[] into .reg24[]. `.reg24[] = *(int*).imm24[]`

1110110101000100			neg			2		2F				SZ-H-VNC	The contents of .reg8[7;1] are negated (two's complement). Operation is the same as subtracting .reg8[7;1] from zero. `.reg8[7;1] = -.reg8[7;1]`
1110110101..1100			mlt reg24		2		2F+4				--------	Multiplies the two lower bytes of .reg24[] together and stores the result back. `.reg24[] = (.reg24[] & 0xFF) * (.reg24[] >> 8 & 0xFF)`
1110110101010100........		lea ix,iy+ofs8		3		3F				--------	Stores .regi[1] plus .ofs8[] into .regi[0]. `.regi[0] = .regi[1] + .ofs8[]`
1110110101100100........		tst a,imm8		3		3F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .imm8[] and affects flags according to the result. .reg8[7;1] is not modified.
1110110101110100........		tstio imm8		3		3F+1R				SZ-1-P00	Bitwise AND on .imm8[] with a byte read from port .reg8[1;1] and affects flags according to the result.

1110110101000101			retn			2		3F+(2+.l)R+1			--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before. `.iff1[] = .iff2[], .regpc[] = *(*(int**)&.reg24[3;1])++`
1110110101001101			reti			2		3F+(2+.l)R+1			--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. `.regpc[] = *(*(int**)&.reg24[3;1])++`
1110110101010101........		lea iy,ix+ofs8		3		3F				--------	Stores .regi[0] plus .ofs8[] into .regi[1]. `.regi[1] = .regi[0] + .ofs8[]`
1110110101100101........		pea ix+ofs8		3		3F+(2+.l)W			--------	.reg24[3;1] is decremented by the word size and .regi[0] plus .ofs8[] is stored into the word of memory pointed to by .reg24[3;1]. `*--*(int**)&.reg24[3;1] = .regi[0] + .ofs8[]`
1110110101101101			ld mb,a			2		2F				--------	Stores the value of .reg8[7;1] into .regmb[]. `.regmb[] = .reg8[7;1]`
1110110101111101			stmix			2		2F				--------	Sets the mixed memory mode flag. `.madl[] = 1`

1110110101000110			im 0			2		2F				--------	Sets interrupt mode 0.
1110110101010110			im 1			2		2F				--------	Sets interrupt mode 1.
1110110101011110			im 2			2		2F				--------	Sets interrupt mode 2.
1110110101100110........		pea iy+ofs8		3		3F+(2+.l)W			--------	.reg24[3;1] is decremented by the word size and .regi[1] plus .ofs8[] is stored into the word of memory pointed to by .reg24[3;1].  `*--*(int**)&.reg24[3;1] = .regi[1] + .ofs8[]`
1110110101101110			ld a,mb			2		2F				--------	Stores the value of .regmb[] into .reg8[7;1]. `.reg8[7;1] = .regmb[]`
1110110101110110			slp			2		2F				--------	Suspends CPU operation until an interrupt or reset occurs.
1110110101111110			rsmix			2		2F				--------	Resets the mixed memory mode flag. `.madl[] = 0`

1110110101000111			ld i,a			2		2F				--------	Stores the value of .reg8[7;1] into .reg8ir[0;1]. `.reg8ir[0;1] = .reg8[7;1]`
1110110101001111			ld r,a			2		2F				--------	Stores the value of .reg8[7;1] into .reg8ir[1;1]. `.reg8ir[1;1] = .reg8[7;1]`
1110110101010111			ld a,i			2		2F				SZ-0-*0-	Stores the value of .reg8ir[0;1] into .reg8[7;1]. `.reg8[7;1] = .reg8ir[0;1]`
1110110101011111			ld a,r			2		2F				SZ-0-*0-	Stores the value of .reg8ir[1;1] into .reg8[7;1]. `.reg8[7;1] = .reg8ir[1;1]`
1110110101100111			rrd			2		2F+1R+1W+1			SZ-0-P0-	The contents of the low-nibble of .reg8[6;1] are copied to the low-order nibble of .reg8[7;1]. The previous contents are copied to the high-order nibble of .reg8[6;1]. The previous contents are copied to the low-order nibble of .reg8[6;1].
1110110101101111			rld			2		2F+1R+1W+1			SZ-0-P0-	The contents of the low-order nibble of .reg8[6;1] are copied to the high-order nibble of .reg8[6;1]. The previous contents are copied to the low-order nibble of .reg8[7;1]. The previous contents are copied to the low-order nibble of .reg8[6;1].

1110110110100000			ldi			2		2F+1R+1W+1			---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1] and .reg24[1;1] are incremented and .reg24[0;1] is decremented. `*(char*).reg24[1;1]++ = *(char*).reg24[2;1]++, --.reg24[0;1]`
1110110110101000			ldd			2		2F+1R+1W+1			---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1], .reg24[1;1], and .reg24[0;1] are decremented. `*(char*).reg24[1;1]-- = *(char*).reg24[2;1]--, --.reg24[0;1]`
1110110110110000			ldir			2		2F+(1R+1W+1)*bc			---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1] and .reg24[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions. `while (*(char*).reg24[1;1]++ = *(char*).reg24[2;1]++, --.reg24[0;1])`
1110110110111000			lddr			2		2F+(1R+1W+1)*bc			---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1], .reg24[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions. `while (*(char*).reg24[1;1]-- = *(char*).reg24[2;1]--, --.reg24[0;1])`

1110110110100001			cpi			2		2F+1R				SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented.
1110110110101001			cpd			2		2F+1R				SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] and .reg24[0;1] are decremented.
1110110110110001			cpir			2		2F+(1R+2)*bc-1			SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero and .f[1] is not set, this operation is repeated. Interrupts can trigger between repetitions.
1110110110111001			cpdr			2		2F+(1R+2)*bc-1			SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero and .f[1] is not set, this operation is repeated. Interrupts can trigger between repetitions.

1110110110000010			inim			2		2F+1R+1W+1			?*-?-?*?	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001010			indm			2		2F+1R+1W+1			?*-?-?*?	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010010			inimr			2		2F+(1R+1W+1)*b			-*----*-	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented .reg8[0;1] and is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110011010			indmr			2		2F+(1R+1W+1)*b			-*----*-	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110100010			ini			2		2F+1R+1W+1			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented.
1110110110101010			ind			2		2F+1R+1W+1			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[0;1] are decremented.
1110110110110010			inir			2		2F+(1R+1W+1)*b			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110111010			indr			2		2F+(1R+1W+1)*b			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[0;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110111000010			inirx			2		2F+(1R+1W+1)*bc			-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110111001010			indrx			2		2F+(1R+1W+1)*bc			-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.

1110110110000011			otim			2		2F+1R+1W+1			?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001011			otdm			2		2F+1R+1W+1			?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010011			otimr			2		2F+(1R+1W+1)*b			?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1] and .reg8[1;1] are incremented .reg8[0;1] and is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110011011			otdmr			2		2F+(1R+1W+1)*b			?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110100011			outi			2		2F+1R+1W+1			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented.
1110110110101011			outd			2		2F+1R+1W+1			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[0;1] are decremented.
1110110110110011			otir			2		2F+(1R+1W+1)*b			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110111011			otdr			2		2F+(1R+1W+1)*b			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[0;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110111000011			otirx			2		2F+(1R+1W+1)*bc			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110111001011			otdrx			2		2F+(1R+1W+1)*bc			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.

1110110110000100			ini2			2		2F+1R+1W+1			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001100			ind2			2		2F+1R+1W+1			-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010100			ini2r			2		2F+(1R+1W+1)*bc			-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg16[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110011100			ind2r			2		2F+(1R+1W+1)*bc			-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg16[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110100100			outi2			2		2F+1R+1W+1			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110101100			outd2			2		2F+1R+1W+1			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110110100			oti2r			2		2F+(1R+1W+1)*bc			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] and .reg16[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.
1110110110111100			otd2r			2		2F+(1R+1W+1)*bc			-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1], .reg16[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger between repetitions.

1110110111000111			ld i,hl			2		2F				--------	Stores the value of .reg16[2;1] into .reg8ir[0;1]. `.reg8ir[0;1] = .reg16[2;1]`
1110110111010111			ld hl,i			2		2F				00-0-000	Stores the value of (.regmb[] << 16) + .reg8ir[0;1] into .reg24[2;1]. `.reg24[2;1] = (.regmb[] << 16) + .reg8ir[0;1]`

11101101........			trap			2		2F				--------	It's a trap!


;IX BIT INSTRUCTIONS

1101110111001011........00000110	rlc (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to .f[3] and bit 0.
1101110111001011........00001110	rrc (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to .f[3] and bit 7.
1101110111001011........00010110	rl (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to .f[3] and the previous contents of .f[3] are copied to bit 0.
1101110111001011........00011110	rr (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of .f[3] are copied to bit 7.
1101110111001011........00100110	sla (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted left one bit position. The contents of bit 7 are copied to .f[3] and a zero is put into bit 0.
1101110111001011........00101110	sra (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of bit 7 are unchanged.
1101110111001011........00111110	srl (ix+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to .f[3] and a zero is put into bit 7.

1101110111001011........01...110	bit imm3,(ix+ofs8)	4		4F+1R				?Z-1-?0-	Tests bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011........10...110	res imm3,(ix+ofs8)	4		4F+1R+1W+1			--------	Resets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011........11...110	set imm3,(ix+ofs8)	4		4F+1R+1W+1			--------	Sets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011................	trap			4		4F				--------	It's a trap!


;IX PRIMARY INSTRUCTIONS

1101110100..1001			add ix,reg24		2		2F				---H--NC	The value of .reg24[] is added to .regi[]. `.regi[] += .reg24[]`
1101110100100001................	ld ix,imm24		5		(4+.il)F			--------	Loads .imm24[] into .regi[]. `.regi[] = .imm24[]`
1101110100110001........		ld iy,(ix+ofs8)		3		3F+(2+.il)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regiopp[]. `.regiopp[] = *(int*)(.regi[] + .ofs8[])`

1101110100100010................	ld (imm24),ix		5		(4+.il)F+(2+.l)W		--------	Stores .regi[] into the word of memory pointed to by .imm24[]. `*(int*).imm24[] = .regi[]`
1101110100101010................	ld ix,(imm24)		5		(4+.il)F+(2+.l)R		--------	Loads the word of memory pointed to by .imm24[] into .regi[]. `.regi[] = *(int*).imm24[]`

1101110100100011			inc ix			2		2F				--------	Adds one to .regi[]. `.regi[]++`
1101110100101011			dec ix			2		2F				--------	Subtracts one from .regi[]. `.regi[]--`

110111010010.100			inc reg8index		2		2F				SZ-H-VN-	Adds one to .regi8[]. `.regi8[]++`
1101110100110100........		inc (ix+ofs8)		3		3F+1R+1W+1			SZ-H-VN-	Adds one to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[])++`

110111010010.101			dec reg8index		2		2F				SZ-H-VN-	Subtracts one from .regi8[]. `.regi8[]--`
1101110100110101........		dec (ix+ofs8)		3		3F+1R+1W+1			SZ-H-VN-	Subtracts one from the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[])--`

110111010010.110........		ld reg8index,imm8	3		3F				--------	Loads .imm8[] into .regi8[]. `.regi8[] = .imm8[]`
1101110100110110................	ld (ix+ofs8),imm8	4		4F+1W				--------	Stores .imm8[] to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[]) = .imm8[]`
1101110100111110........		ld (ix+ofs8),iy		3		3F+(2+.l)W			--------	Stores .regiopp[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .regiopp[]`

1101110100110111........		ld ix,(ix+ofs8)		3		3F+(2+.l)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regi[]. `.regi[] = *(int*)(.regi[] + .ofs8[])`
1101110100..0111........		ld reg24,(ix+ofs8)	3		3F+(2+.l)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .reg24[]. `.reg24[] = *(int*)(.regi[] + .ofs8[])`
1101110100111111........		ld (ix+ofs8),ix		3		3F+(2+.l)W			--------	Stores .regi[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .regi[]`
1101110100..1111........		ld (ix+ofs8),reg24	3		3F+(2+.l)W			--------	Stores .reg24[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .reg24[]`

1101110101110110			trap			2		2F				--------	It's a trap!
1101110101...110........		ld reg8,(ix+ofs8)	3		3F+1R				--------	Loads the byte of memory pointed to by .regi[] plus .ofs8[] into .reg8[]. `.reg8[] = *(char*)(.regi[] + .ofs8[])`
1101110101110...........		ld (ix+ofs8),reg8	3		3F+1W				--------	Stores .reg8[] to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[]) = .reg8[]`
1101110101...10.			ld reg8,reg8index	2		2F				--------	The contents of .regi8[] are loaded into .reg8[]. `.reg8[] = .regi8[]`
110111010110....			ld reg8index,reg8	2		2F				--------	The contents of .reg8[] are loaded into .regi8[]. `.regi8[] = .reg8[]`

110111011000010.			add a,reg8index		2		2F				SZ-H-VNC	Adds .regi8[] to .reg8[7;1]. `.reg8[7;1] += .regi8[]`
1101110110000110........		add a,(ix+ofs8)		3		3F+1R				SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] to .reg8[7;1]. `.reg8[7;1] += *(char*)(.regi[] + .ofs8[])`
110111011000110.			adc a,reg8index		2		2F				SZ-H-VNC	Adds .regi8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += .regi8[] + .f[3]`
1101110110001110........		adc a,(ix+ofs8)		3		3F+1R				SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += *(char*)(.regi[] + .ofs8[]) + .f[3]`
110111011001010.			sub a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1]. `.reg8[7;1] -= .regi8[]`
1101110110010110........		sub a,(ix+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1]. `.reg8[7;1] -= *(char*)(.regi[] + .ofs8[])`
110111011001110.			sbc a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= .regi8[] + .f[3]`
1101110110011110........		sbc a,(ix+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= *(char*)(.regi[] + .ofs8[]) + .f[3]`
110111011010010.			and a,reg8index		2		2F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .regi8[]. `.reg8[7;1] &= .regi8[]`
1101110110100110........		and a,(ix+ofs8)		3		3F+1R				SZ-1-P00	Bitwise AND on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] &= *(char*)(.regi[] + .ofs8[])`
110111011010110.			xor a,reg8index		2		2F				SZ-0-P00	Bitwise XOR on .reg8[7;1] with .regi8[]. `.reg8[7;1] ^= .regi8[]`
1101110110101110........		xor a,(ix+ofs8)		3		3F+1R				SZ-0-P00	Bitwise XOR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] ^= *(char*)(.regi[] + .ofs8[])`
110111011011010.			or a,reg8index		2		2F				SZ-0-P00	Bitwise OR on .reg8[7;1] with .regi8[]. `.reg8[7;1] |= .regi8[]`
1101110110110110........		or a,(ix+ofs8)		3		3F+1R				SZ-0-P00	Bitwise OR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] |= *(char*)(.regi[] + .ofs8[])`
110111011011110.			cp a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
1101110110111110........		cp a,(ix+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

1101110111100001			pop ix			2		2F+(2+.l)R			--------	The word of memory pointed to by .reg24[3;1] is stored into .regi[] and .reg24[3;1] is incremented by the word size. `*.regi[] = *(*(int**)&.reg24[3;1])++`
1101110111101001			jp (ix)			2		4F				--------	Loads the value of .regi[] into .regpc[]. `.regpc[] = .regi[]`
1101110111111001			ld sp,ix		2		2F				--------	Loads the value of .regi[] into .reg24[3;1]. `.reg24[3;1] = .regi[]`

;1101110111001011			IX BIT INSTRUCTIONS
1101110111100011			ex (sp),ix		2		2F+(2+.l)R+(2+.l)W		--------	Exchanges the word of memory pointed to by .reg24[3;1] with .regi[].

1101110111100101			push ix			2		2F+(2+.l)W			--------	.reg24[3;1] is decremented by the word size and .regi[] is stored into the word of memory pointed to by .reg24[3;1]. `*--*(int**)&.reg24[3;1] = .regi[]`

11011101........			trap			2		2F				--------	It's a trap!


;IY BIT INSTRUCTIONS

1111110111001011........00000110	rlc (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to .f[3] and bit 0.
1111110111001011........00001110	rrc (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to .f[3] and bit 7.
1111110111001011........00010110	rl (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to .f[3] and the previous contents of .f[3] are copied to bit 0.
1111110111001011........00011110	rr (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of .f[3] are copied to bit 7.
1111110111001011........00100110	sla (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted left one bit position. The contents of bit 7 are copied to .f[3] and a zero is put into bit 0.
1111110111001011........00101110	sra (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to .f[3] and the previous contents of bit 7 are unchanged.
1111110111001011........00111110	srl (iy+ofs8)		4		4F+1R+1W+1			SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to .f[3] and a zero is put into bit 7.

1111110111001011........01...110	bit imm3,(iy+ofs8)	4		4F+1R				?Z-1-?0-	Tests bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011........10...110	res imm3,(iy+ofs8)	4		4F+1R+1W+1			--------	Resets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011........11...110	set imm3,(iy+ofs8)	4		4F+1R+1W+1			--------	Sets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011................	trap			4		4F				--------	It's a trap!


;IY PRIMARY INSTRUCTIONS

1111110100..1001			add iy,reg24		2		2F				---H--NC	The value of .reg24[] is added to .regi[]. `.regi[] += .reg24[]`
1111110100100001................	ld iy,imm24		5		(4+.il)F			--------	Loads .imm24[] into .regi[]. `.regi[] = .imm24[]`
1111110100110001........		ld ix,(iy+ofs8)		3		3F+(2+.il)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regiopp[]. `.regiopp[] = *(int*)(.regi[] + .ofs8[])`

1111110100100010................	ld (imm24),iy		5		(4+.il)F+(2+.l)W		--------	Stores .regi[] into the word of memory pointed to by .imm24[]. `*(int*).imm24[] = .regi[]`
1111110100101010................	ld iy,(imm24)		5		(4+.il)F+(2+.l)R		--------	Loads the word of memory pointed to by .imm24[] into .regi[]. `.regi[] = *(int*).imm24[]`

1111110100100011			inc iy			2		2F				--------	Adds one to .regi[]. `.regi[]++`
1111110100101011			dec iy			2		2F				--------	Subtracts one from .regi[]. `.regi[]--`

111111010010.100			inc reg8index		2		2F				SZ-H-VN-	Adds one to .regi8[]. `.regi8[]++`
1111110100110100........		inc (iy+ofs8)		3		3F+1R+1W+1			SZ-H-VN-	Adds one to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[])++`

111111010010.101			dec reg8index		2		2F				SZ-H-VN-	Subtracts one from .regi8[]. `.regi8[]--`
1111110100110101........		dec (iy+ofs8)		3		3F+1R+1W+1			SZ-H-VN-	Subtracts one from the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[])--`

111111010010.110........		ld reg8index,imm8	3		3F				--------	Loads .imm8[] into .regi8[]. `.regi8[] = .imm8[]`
1111110100110110................	ld (iy+ofs8),imm8	4		4F+1W				--------	Stores .imm8[] to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[]) = .imm8[]`
1111110100111110........		ld (iy+ofs8),ix		3		3F+(2+.l)W			--------	Stores .regiopp[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .regiopp[]`

1111110100110111........		ld iy,(iy+ofs8)		3		3F+(2+.l)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regi[]. `.regi[] = *(int*)(.regi[] + .ofs8[])`
1111110100..0111........		ld reg24,(iy+ofs8)	3		3F+(2+.l)R			--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .reg24[]. `.reg24[] = *(int*)(.regi[] + .ofs8[])`
1111110100111111........		ld (iy+ofs8),iy		3		3F+(2+.l)W			--------	Stores .regi[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .regi[]`
1111110100..1111........		ld (iy+ofs8),reg24	3		3F+(2+.l)W			--------	Stores .reg24[] into the word of memory pointed to by .regi[] plus .ofs8[]. `*(int*)(.regi[] + .ofs8[]) = .reg24[]`

1111110101110110			trap			2		2F				--------	It's a trap!
1111110101...110........		ld reg8,(iy+ofs8)	3		3F+1R				--------	Loads the byte of memory pointed to by .regi[] plus .ofs8[] into .reg8[]. `.reg8[] = *(char*)(.regi[] + .ofs8[])`
1111110101110...........		ld (iy+ofs8),reg8	3		3F+1W				--------	Stores .reg8[] to the byte of memory pointed to by .regi[] plus .ofs8[]. `*(char*)(.regi[] + .ofs8[]) = .reg8[]`
1111110101...10.			ld reg8,reg8index	2		2F				--------	The contents of .regi8[] are loaded into .reg8[]. `.reg8[] = .regi8[]`
111111010110....			ld reg8index,reg8	2		2F				--------	The contents of .reg8[] are loaded into .regi8[]. `.regi8[] = .reg8[]`

111111011000010.			add a,reg8index		2		2F				SZ-H-VNC	Adds .regi8[] to .reg8[7;1]. `.reg8[7;1] += .regi8[]`
1111110110000110........		add a,(iy+ofs8)		3		3F+1R				SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] to .reg8[7;1]. `.reg8[7;1] += *(char*)(.regi[] + .ofs8[])`
111111011000110.			adc a,reg8index		2		2F				SZ-H-VNC	Adds .regi8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += .regi8[] + .f[3]`
1111110110001110........		adc a,(iy+ofs8)		3		3F+1R				SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] and .f[3] to .reg8[7;1]. `.reg8[7;1] += *(char*)(.regi[] + .ofs8[]) + .f[3]`
111111011001010.			sub a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1]. `.reg8[7;1] -= .regi8[]`
1111110110010110........		sub a,(iy+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1]. `.reg8[7;1] -= *(char*)(.regi[] + .ofs8[])`
111111011001110.			sbc a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= .regi8[] + .f[3]`
1111110110011110........		sbc a,(iy+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] and .f[3] from .reg8[7;1]. `.reg8[7;1] -= *(char*)(.regi[] + .ofs8[]) + .f[3]`
111111011010010.			and a,reg8index		2		2F				SZ-1-P00	Bitwise AND on .reg8[7;1] with .regi8[]. `.reg8[7;1] &= .regi8[]`
1111110110100110........		and a,(iy+ofs8)		3		3F+1R				SZ-1-P00	Bitwise AND on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] &= *(char*)(.regi[] + .ofs8[])`
111111011010110.			xor a,reg8index		2		2F				SZ-0-P00	Bitwise XOR on .reg8[7;1] with .regi8[]. `.reg8[7;1] ^= .regi8[]`
1111110110101110........		xor a,(iy+ofs8)		3		3F+1R				SZ-0-P00	Bitwise XOR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] ^= *(char*)(.regi[] + .ofs8[])`
111111011011010.			or a,reg8index		2		2F				SZ-0-P00	Bitwise OR on .reg8[7;1] with .regi8[]. `.reg8[7;1] |= .regi8[]`
1111110110110110........		or a,(iy+ofs8)		3		3F+1R				SZ-0-P00	Bitwise OR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[]. `.reg8[7;1] |= *(char*)(.regi[] + .ofs8[])`
111111011011110.			cp a,reg8index		2		2F				SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
1111110110111110........		cp a,(iy+ofs8)		3		3F+1R				SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

1111110111100001			pop iy			2		2F+(2+.l)R			--------	The word of memory pointed to by .reg24[3;1] is stored into .regi[] and .reg24[3;1] is incremented by the word size. `*.regi[] = *(*(int**)&.reg24[3;1])++`
1111110111101001			jp (iy)			2		4F				--------	Loads the value of .regi[] into .regpc[]. `.regpc[] = .regi[]`
1111110111111001			ld sp,iy		2		2F				--------	Loads the value of .regi[] into .reg24[3;1]. `.reg24[3;1] = .regi[]`

;1101110111001011			IY BIT INSTRUCTIONS
1111110111100011			ex (sp),iy		2		2F+(2+.l)R+(2+.l)W		--------	Exchanges the word of memory pointed to by .reg24[3;1] with .regi[].

1111110111100101			push iy			2		2F+(2+.l)W			--------	.reg24[3;1] is decremented by the word size and .regi[] is stored into the word of memory pointed to by .reg24[3;1]. `*--*(int**)&.reg24[3;1] = .regi[]`

11111101........			trap			2		2F				--------	It's a trap!
